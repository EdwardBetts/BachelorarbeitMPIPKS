import numpy as np
from scipy.optimize import fsolve
from scipy.optimize import newton_krylov

def n_bar(n_bar_red, N, state):
    ''' Get full occupations from reduced array.
    '''
    n_red = N - np.sum(n_bar_red)
    return np.append(np.append(n_bar_red[:state], [n_red]), n_bar_red[state:])

def MF_equations(n_bar_red, R, N, red_state):
    ''' Defines the system of nonlinear equations describing
        the mean occupations n_bar in mean field approximation

        n_bar_red - thermodynamic mean occupation values (M-1 dim. array)
        R - rate matrix
        N - particle number
    '''
    n_b = n_bar(n_bar_red, N, red_state)
    values = ((np.dot(R, n_b) - np.dot(n_b, R)) * n_b + \
            + np.dot(R, n_b) - R.sum(axis=0) * n_b)
    return np.delete(values, red_state) 

def MF_equations_withA(n_bar_red, R, A, Rsum, N, red_state):
    ''' Defines the system of nonlinear equations describing
        the mean occupations n_bar in mean field approximation

        n_bar_red - thermodynamic mean occupation values (M-1 dim. array)
        R - rate matrix
        A - matr of rate diff
        N - particle number
    '''
    n_b = n_bar(n_bar_red, N, red_state)

    values = (np.dot(A, n_b) * n_b + \
            + np.dot(R, n_b) - Rsum * n_b)
    return np.delete(values, red_state) 

def MF_jac_withA(n_bar_red, R, A, Rsum, N, red_state):
    ''' Defines the system of nonlinear equations describing
        the mean occupations n_bar in mean field approximation

        n_bar_red - thermodynamic mean occupation values (M-1 dim. array)
        R - rate matrix
        A - matr of rate diff
        N - particle number
    '''
    n_b = n_bar(n_bar_red, N, red_state)
    M = len(n_b)
    jac = (np.diag(np.dot(A, n_b) - Rsum) + \
     +np.transpose((-A+np.outer(A[:, red_state], np.ones(M))) * n_b) + R - np.outer(R[:, red_state], np.ones(M)))
      
    return jac[1:, 1:]

def MF_jac(n_bar_red, R, N, red_state):
    assert red_state == 0
    n_b = n_bar(n_bar_red, N, red_state)
    M = len(n_b)
    jac = (np.diag(np.dot(R, n_b) - np.dot(n_b, R)- R.sum(axis=0)) + \
              +np.transpose((-R + np.transpose(R)+np.outer(R[:, red_state]-R[red_state, :], np.ones(M))) * n_b) + R - np.outer(R[:, red_state], np.ones(M)))
      
    return jac[1:, 1:]

def MF_curves_temp(R_gen, n, b_or_lg_b_min, lg_b_max=None, steps=None, selected=None,
                   nasymp=None, debug=False, usederiv=False, maxsteps=40, M_sw_solvers=500):
    ''' Numerically solves the MF equations of the many body
        master equation generated by the rate matrix R

        R - rate matrix
        lg_n_min - logarithm of minimum filling
        lg_n_max - logarithm of maximum filling
    ''' 
    
    if not lg_b_max==None and not steps==None:
        beta = np.logspace(b_or_lg_b_min, lg_b_max, steps, endpoint=True)  # filling factors
    else:
        beta = b_or_lg_b_min
    
    R = R_gen(beta[0])
    M = np.shape(R)[0]
    log = 'Calculation successful.'

    curves = np.zeros((len(beta), M))           # matrix for numerical results

    
    if debug:
        print "Beginne Suchalgorithmus..."
    
    for i in xrange(len(beta)):
        if debug:
            print "M =", M, ",", i *100 /float(len(beta)), "%" 
        
        red_state = 0
        
        if i == 0:
            init = np.delete(np.ones(M) * n, red_state)
        else:
            if usederiv and i>1:
                deriv = (curves[i-1] - curves[i-2]) / (beta[i-1]-beta[i-2])
                n_t = curves[i-1] + deriv * (beta[i]-beta[i-1])
                #n_t *= n / np.sum(n_t)
                init = np.delete(n_t, red_state)
            else:
                init = beta[i-1] / beta[i] * init
            
            R = R_gen(beta[i])
        
        A = R - np.transpose(R)
        Rsum = R.sum(axis=0)
        
        if M < M_sw_solvers:
            init, info, ier, msg = fsolve(MF_equations_withA, init, args=(R, A, Rsum, M * n, red_state), fprime=MF_jac_withA, full_output=True)
        else:
            args=(R, M * n, red_state)
            func = lambda x: MF_equations(x, *args)
            try:
                init = newton_krylov(func, init, verbose=0, maxiter=500)
                ier = 1
            except:
                ier = 0

        n_t = n_bar(init, M * n, red_state)

        if (np.any(n_t < 0.) or ier != 1) and not i==0: 
            print "Fehler: Erhoehe Schrittweite"
            steps = 4
            mysuc = False
            bet_old = beta[i-1]
            oldinit = np.delete(curves[i-1], red_state)
            deriv = None
            while not mysuc:
                init = oldinit
                for bet_inter in np.logspace(np.log10(bet_old), np.log10(beta[i]), steps)[1:]:
                    if steps > maxsteps:
                        print "Erneuter Fehler, gebe auf..."
                        log = "An error occured!"
                        n_t = np.zeros(M)
                        mysuc = True
                        break
                    R = R_gen(bet_inter)
                    if usederiv and deriv != None:
                        init = init + deriv * (bet_inter-bet_old)
                    else:
                        init = bet_old / bet_inter * init
                    if M < M_sw_solvers:
                        init, info, ier, msg = fsolve(MF_equations, init, args=(R, M * n, red_state), fprime=MF_jac, full_output=True)
                        mysuc = True
                    else:
                        args=(R, M * n, red_state)
                        func = lambda x: MF_equations(x, *args)
                        try:
                            init = newton_krylov(func, init, verbose=1, maxiter=200)
                            ier = 1
                            mysuc = True
                        except:
                            ier = 0
                    
                    n_t = n_bar(init, M * n, red_state)
                    if np.any(n_t < 0.) or ier != 1: 
                        print "Erneuter Fehler, erhoehe weiter Schrittweite..."
                        steps += 4
                        mysuc = False
                        break
                    if usederiv:
                        deriv = (init - oldinit) / (bet_inter-bet_old)

                    oldinit = init
                    bet_old = bet_inter
                    
                    
            

        if np.all(n_t >= 0.):
            curves[i] = n_t
        
    return beta, curves, log